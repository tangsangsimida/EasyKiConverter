name: Packaging (Linux)

on:
  push:
    tags:
      - 'v*'
      - 'V*'
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create GitHub Release'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  packages: read

env:
  PRODUCT: EasyKiConverter
  DOCKER_IMAGE: ghcr.io/tangsangsimida/easykiconverter/build-env:latest

jobs:
  # ===========================================================================
  # 阶段 1: 核心构建 (Build Once)
  # 编译代码，处理依赖，生成 AppDir 目录结构，供后续打包任务使用
  # ===========================================================================
  build-core:
    name: 'Build Core (Compile & Prepare)'
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Version
        id: version
        uses: ./.github/actions/get-version

      - name: Export Version
        run: |
          echo "VERSION=${{ steps.version.outputs.VERSION }}" >> $GITHUB_ENV
          echo "GIT_HASH=${{ steps.version.outputs.GIT_HASH }}" >> $GITHUB_ENV

      - name: Fix Git Safe Directory
        run: git config --global --add safe.directory $GITHUB_WORKSPACE

      - name: Compile & Install
        run: |
          set -x
          APPIMAGE_DST_PATH=$GITHUB_WORKSPACE/${PRODUCT}.AppDir
          mkdir -p ${APPIMAGE_DST_PATH}

          # 编译
          cmake -B build -G "Ninja" \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_INSTALL_PREFIX=/usr \
            -DCMAKE_C_COMPILER_LAUNCHER=ccache \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DENABLE_SYMBOL_FOOTPRINT_DEBUG_EXPORT=OFF \
            -DVERSION_FROM_CI=${{ env.VERSION }}

          cmake --build build --config RelWithDebInfo --parallel
          cmake --install build --prefix ${APPIMAGE_DST_PATH}/usr
          rm -rf ${APPIMAGE_DST_PATH}/usr/include

          # 配置元数据
          cat > ${APPIMAGE_DST_PATH}/EasyKiConverter.desktop <<EOF
          [Desktop Entry]
          Type=Application
          Name=EasyKiConverter
          Comment=Convert LCSC and EasyEDA components to KiCad libraries
          Exec=EasyKiConverter
          Icon=app_icon
          Categories=Development;Electronics;
          Terminal=false
          EOF
          cp resources/icons/app_icon.png ${APPIMAGE_DST_PATH}/app_icon.png

          # 关键步骤：运行 linuxdeploy 填充依赖库 (Qt libs 等) 到 AppDir
          # 注意：这里不生成 AppImage 文件，只处理目录内容
          # --icon-file 参数必须指向 AppDir 中的图标文件，而不是源路径
          linuxdeploy --appdir ${APPIMAGE_DST_PATH} --plugin qt \
            --executable ${APPIMAGE_DST_PATH}/usr/bin/EasyKiConverter \
            --desktop-file ${APPIMAGE_DST_PATH}/EasyKiConverter.desktop \
            --icon-file ${APPIMAGE_DST_PATH}/app_icon.png

      - name: Upload AppDir Artifact
        uses: actions/upload-artifact@v4
        with:
          name: built-appdir
          path: ${{ github.workspace }}/${{ env.PRODUCT }}.AppDir
          retention-days: 1

  # ===========================================================================
  # 阶段 2: 独立打包任务 (Package Anywhere)
  # 并行执行，互不干扰
  # ===========================================================================

  pack-appimage:
    name: 'Package: AppImage'
    needs: build-core
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4 # 需要 checkout 以便 linuxdeploy 某些插件工作正常
      - uses: ./.github/actions/get-version
        id: version

      - name: Download AppDir
        uses: actions/download-artifact@v4
        with:
          name: built-appdir
          path: ${{ env.PRODUCT }}.AppDir

      - name: Debug - List AppDir
        run: ls -R ${{ env.PRODUCT }}.AppDir

      - name: Generate AppImage
        run: |
          # 重新运行 linuxdeploy 以生成 AppImage
          # 必须再次指定 executable 和 desktop-file 否则 AppRun 可能不会正确链接
          linuxdeploy --appdir ${{ env.PRODUCT }}.AppDir --plugin qt \
            --executable ${{ env.PRODUCT }}.AppDir/usr/bin/EasyKiConverter \
            --desktop-file ${{ env.PRODUCT }}.AppDir/EasyKiConverter.desktop \
            --output appimage

          # 重命名
          mv EasyKiConverter-*.AppImage \
             ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}.x86_64.AppImage

          # Checksum
          sha256sum *.AppImage | tee ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}.x86_64.AppImage.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyKiConverter-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}-x86_64.AppImage
          path: |
            *.AppImage
            *.sha256sum

  pack-deb:
    name: 'Package: DEB (Debian/Ubuntu)'
    needs: build-core
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/get-version
        id: version

      - name: Download AppDir
        uses: actions/download-artifact@v4
        with:
          name: built-appdir
          path: .

      - name: Debug - List AppDir
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Checking for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            echo "Found AppDir directory"
            ls -R ${{ env.PRODUCT }}.AppDir | head -50
          else
            echo "AppDir directory not found, checking for nested directories..."
            find . -maxdepth 2 -type d -name "AppDir" -o -name "usr" 2>/dev/null || true
          fi

      - name: Generate DEB
        run: |
          export VERSION="${{ steps.version.outputs.VERSION}}"

          # 自动检测 AppDir 位置
          echo "=== Searching for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/${{ env.PRODUCT }}.AppDir"
            echo "Found AppDir at: $APP_DIR"
          elif [ -d "AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/AppDir"
            echo "Found AppDir at: $APP_DIR"
          else
            # 检查当前目录是否包含 AppDir 的特征文件（usr/bin/EasyKiConverter）
            if [ -f "usr/bin/EasyKiConverter" ] && [ -f "AppRun" ]; then
              # nfpm 不支持使用根目录，需要创建一个子目录
              echo "Found AppDir structure in current directory, creating subdirectory for nfpm"
              mkdir -p AppDir_temp
              mv usr lib AppRun *.desktop app_icon.png AppDir_temp/ 2>/dev/null || true
              export APP_DIR="${GITHUB_WORKSPACE}/AppDir_temp"
              echo "Using AppDir at: $APP_DIR"
            else
              # 查找包含 usr/bin 的子目录
              FOUND_DIR=$(find . -maxdepth 2 -type d -name "usr" -not -path '.' -exec dirname {} \; 2>/dev/null | head -1)
              if [ -n "$FOUND_DIR" ] && [ "$FOUND_DIR" != "." ]; then
                export APP_DIR="${GITHUB_WORKSPACE}/${FOUND_DIR}"
                echo "Found AppDir-like structure at: $APP_DIR"
              else
                echo "ERROR: Could not find AppDir!"
                echo "Available directories:"
                find . -maxdepth 2 -type d
                exit 1
              fi
            fi
          fi

          echo "=== APP_DIR = $APP_DIR ==="
          echo "=== Verifying APP_DIR ==="
          ls -la "$APP_DIR" | head -20

          # 准备脚本（创建所有必需的脚本文件）
          mkdir -p scripts
          echo -e "#!/bin/sh\nif which update-desktop-database >/dev/null 2>&1; then update-desktop-database -q; fi" > scripts/postinstall.sh
          echo -e "#!/bin/sh\n# Pre-remove script (empty)" > scripts/preremove.sh
          chmod +x scripts/*.sh

          # 使用 sed 动态替换 nfpm.yaml 中的 ${APP_DIR} 变量
          sed "s|\${APP_DIR}|$APP_DIR|g" deploy/nfpm.yaml > nfpm_temp.yaml

          # 打包
          nfpm pkg --packager deb --target . --config nfpm_temp.yaml

          # 重命名
          find . -name "*.deb" -exec mv {} ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_amd64.deb \;

          # Checksum
          sha256sum *.deb | tee ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_amd64.deb.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyKiConverter-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}-amd64.deb
          path: |
            *.deb
            *.sha256sum

  pack-rpm:
    name: 'Package: RPM (RedHat/Fedora)'
    needs: build-core
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/get-version
        id: version

      - name: Download AppDir
        uses: actions/download-artifact@v4
        with:
          name: built-appdir
          path: .

      - name: Debug - List AppDir
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Checking for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            echo "Found AppDir directory"
            ls -R ${{ env.PRODUCT }}.AppDir | head -50
          else
            echo "AppDir directory not found, checking for nested directories..."
            find . -maxdepth 2 -type d -name "AppDir" -o -name "usr" 2>/dev/null || true
          fi

      - name: Generate RPM
        run: |
          export VERSION="${{ steps.version.outputs.VERSION}}"

          # 自动检测 AppDir 位置
          echo "=== Searching for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/${{ env.PRODUCT }}.AppDir"
            echo "Found AppDir at: $APP_DIR"
          elif [ -d "AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/AppDir"
            echo "Found AppDir at: $APP_DIR"
          else
            # 检查当前目录是否包含 AppDir 的特征文件（usr/bin/EasyKiConverter）
            if [ -f "usr/bin/EasyKiConverter" ] && [ -f "AppRun" ]; then
              # nfpm 不支持使用根目录，需要创建一个子目录
              echo "Found AppDir structure in current directory, creating subdirectory for nfpm"
              mkdir -p AppDir_temp
              mv usr lib AppRun *.desktop app_icon.png AppDir_temp/ 2>/dev/null || true
              export APP_DIR="${GITHUB_WORKSPACE}/AppDir_temp"
              echo "Using AppDir at: $APP_DIR"
            else
              # 查找包含 usr/bin 的子目录
              FOUND_DIR=$(find . -maxdepth 2 -type d -name "usr" -not -path '.' -exec dirname {} \; 2>/dev/null | head -1)
              if [ -n "$FOUND_DIR" ] && [ "$FOUND_DIR" != "." ]; then
                export APP_DIR="${GITHUB_WORKSPACE}/${FOUND_DIR}"
                echo "Found AppDir-like structure at: $APP_DIR"
              else
                echo "ERROR: Could not find AppDir!"
                echo "Available directories:"
                find . -maxdepth 2 -type d
                exit 1
              fi
            fi
          fi

          echo "=== APP_DIR = $APP_DIR ==="
          echo "=== Verifying APP_DIR ==="
          ls -la "$APP_DIR" | head -20

          # 准备脚本（创建所有必需的脚本文件）
          mkdir -p scripts
          echo -e "#!/bin/sh\nif which update-desktop-database >/dev/null 2>&1; then update-desktop-database -q; fi" > scripts/postinstall.sh
          echo -e "#!/bin/sh\n# Pre-remove script (empty)" > scripts/preremove.sh
          chmod +x scripts/*.sh

          # 使用 sed 动态替换 nfpm.yaml 中的 ${APP_DIR} 变量
          sed "s|\${APP_DIR}|$APP_DIR|g" deploy/nfpm.yaml > nfpm_temp.yaml

          nfpm pkg --packager rpm --target . --config nfpm_temp.yaml

          find . -name "*.rpm" -exec mv {} ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_x86_64.rpm \;
          sha256sum *.rpm | tee ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_x86_64.rpm.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyKiConverter-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}-x86_64.rpm
          path: |
            *.rpm
            *.sha256sum

  pack-arch:
    name: 'Package: Arch Linux'
    needs: build-core
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/get-version
        id: version

      - name: Download AppDir
        uses: actions/download-artifact@v4
        with:
          name: built-appdir
          path: .

      - name: Debug - List AppDir
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Checking for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            echo "Found AppDir directory"
            ls -R ${{ env.PRODUCT }}.AppDir | head -50
          else
            echo "AppDir directory not found, checking for nested directories..."
            find . -maxdepth 2 -type d -name "AppDir" -o -name "usr" 2>/dev/null || true
          fi

      - name: Generate Arch Package
        run: |
          export VERSION="${{ steps.version.outputs.VERSION}}"

          # 自动检测 AppDir 位置
          echo "=== Searching for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/${{ env.PRODUCT }}.AppDir"
            echo "Found AppDir at: $APP_DIR"
          elif [ -d "AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/AppDir"
            echo "Found AppDir at: $APP_DIR"
          else
            # 检查当前目录是否包含 AppDir 的特征文件（usr/bin/EasyKiConverter）
            if [ -f "usr/bin/EasyKiConverter" ] && [ -f "AppRun" ]; then
              # nfpm 不支持使用根目录，需要创建一个子目录
              echo "Found AppDir structure in current directory, creating subdirectory for nfpm"
              mkdir -p AppDir_temp
              mv usr lib AppRun *.desktop app_icon.png AppDir_temp/ 2>/dev/null || true
              export APP_DIR="${GITHUB_WORKSPACE}/AppDir_temp"
              echo "Using AppDir at: $APP_DIR"
            else
              # 查找包含 usr/bin 的子目录
              FOUND_DIR=$(find . -maxdepth 2 -type d -name "usr" -not -path '.' -exec dirname {} \; 2>/dev/null | head -1)
              if [ -n "$FOUND_DIR" ] && [ "$FOUND_DIR" != "." ]; then
                export APP_DIR="${GITHUB_WORKSPACE}/${FOUND_DIR}"
                echo "Found AppDir-like structure at: $APP_DIR"
              else
                echo "ERROR: Could not find AppDir!"
                echo "Available directories:"
                find . -maxdepth 2 -type d
                exit 1
              fi
            fi
          fi

          echo "=== APP_DIR = $APP_DIR ==="
          echo "=== Verifying APP_DIR ==="
          ls -la "$APP_DIR" | head -20

          # 准备脚本（创建所有必需的脚本文件）
          mkdir -p scripts
          echo -e "#!/bin/sh\nif which update-desktop-database >/dev/null 2>&1; then update-desktop-database -q; fi" > scripts/postinstall.sh
          echo -e "#!/bin/sh\n# Pre-remove script (empty)" > scripts/preremove.sh
          chmod +x scripts/*.sh

          # 使用 sed 动态替换 nfpm.yaml 中的 ${APP_DIR} 变量
          sed "s|\${APP_DIR}|$APP_DIR|g" deploy/nfpm.yaml > nfpm_temp.yaml

          nfpm pkg --packager archlinux --target . --config nfpm_temp.yaml

          find . -name "*.pkg.tar.zst" -exec mv {} ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_x86_64.pkg.tar.zst \;
          sha256sum *.pkg.tar.zst | tee ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_x86_64.pkg.tar.zst.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyKiConverter-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}-x86_64.pkg.tar.zst
          path: |
            *.pkg.tar.zst
            *.sha256sum

  # ===========================================================================
  # 阶段 3: 独立构建系统任务 (Flatpak)
  # 它们有自己的构建流程，无法复用 build-core 的 AppDir
  # ===========================================================================

  pack-flatpak:
    name: 'Package: Flatpak'
    runs-on: ubuntu-latest
    container:
      image: bilelmoussaoui/flatpak-github-actions:kde-6.6
      options: --privileged
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: ./.github/actions/get-version
        id: version
      - run: git config --global --add safe.directory $GITHUB_WORKSPACE


      - name: Build Flatpak
        uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        with:
          bundle: EasyKiConverter.flatpak
          manifest-path: deploy/flatpak/com.tangsangsimida.EasyKiConverter.yml
          cache-key: flatpak-builder-${{ github.sha }}
          upload-artifact: false
          verbose: true


      - name: Rename & Checksum
        run: |
          FILENAME=${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}.flatpak
          mv EasyKiConverter.flatpak $FILENAME
          sha256sum $FILENAME | tee $FILENAME.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyKiConverter-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}-x86_64.flatpak
          path: |
            *.flatpak
            *.sha256sum

  # ===========================================================================
  # 阶段 4: 发布
  # 汇总所有工件并发布
  # ===========================================================================
  release:
    name: 'Publish Release'
    if: startsWith(github.ref, 'refs/tags/')
    needs: [pack-appimage, pack-deb, pack-rpm, pack-arch, pack-flatpak]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Version
        id: version
        uses: ./.github/actions/get-version

      - name: Generate Changelog
        id: changelog
        shell: bash
        run: |
          PREV_TAG="${{ steps.version.outputs.PREVIOUS_TAG }}"
          CURR_TAG="${{ github.ref_name }}"

          echo "### 变更内容 / Changes" > changelog.md
          echo "" >> changelog.md

          if [ -z "$PREV_TAG" ]; then
            echo "首次发布 / Initial release" >> changelog.md
          else
            echo "对比版本: $PREV_TAG -> $CURR_TAG" >> changelog.md
            echo "" >> changelog.md
            git log ${PREV_TAG}..${CURR_TAG} --oneline --pretty=format:"* %s (%h)" >> changelog.md
          fi

          # 处理特殊字符
          body=$(cat changelog.md)
          echo "BODY<<EOF" >> $GITHUB_OUTPUT
          echo "$body" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: EasyKiConverter-*
          merge-multiple: true
          path: release_assets

      - name: Upload Release Asset
        uses: softprops/action-gh-release@v2
        with:
          files: release_assets/*
          body: ${{ steps.changelog.outputs.BODY }}
          generate_release_notes: false
          draft: true
          prerelease: false
          fail_on_unmatched_files: false
