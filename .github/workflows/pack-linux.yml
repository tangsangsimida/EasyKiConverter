name: Packaging (Linux)

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create GitHub Release'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  packages: read

env:
  PRODUCT: EasyKiConverter
  DOCKER_IMAGE: ghcr.io/tangsangsimida/easykiconverter/build-env:latest

jobs:
  # ===========================================================================
  # 阶段 1: 核心构建 (Build Once)
  # 编译代码，处理依赖，生成 AppDir 目录结构，供后续打包任务使用
  # ===========================================================================
  build-core:
    name: 'Build Core (Compile & Prepare)'
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Version
        id: version
        uses: ./.github/actions/get-version

      - name: Export Version
        run: |
          echo "VERSION=${{ steps.version.outputs.VERSION }}" >> $GITHUB_ENV
          echo "GIT_HASH=${{ steps.version.outputs.GIT_HASH }}" >> $GITHUB_ENV

      - name: Fix Git Safe Directory
        run: git config --global --add safe.directory $GITHUB_WORKSPACE

      - name: Compile & Install
        run: |
          set -x
          APPIMAGE_DST_PATH=$GITHUB_WORKSPACE/${PRODUCT}.AppDir
          mkdir -p ${APPIMAGE_DST_PATH}

          # 编译
          cmake -B build -G "Ninja" \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_INSTALL_PREFIX=/usr \
            -DCMAKE_C_COMPILER_LAUNCHER=ccache \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DENABLE_SYMBOL_FOOTPRINT_DEBUG_EXPORT=OFF \
            -DVERSION_FROM_CI=${{ env.VERSION }}
          
          cmake --build build --config RelWithDebInfo --parallel
          cmake --install build --prefix ${APPIMAGE_DST_PATH}/usr
          rm -rf ${APPIMAGE_DST_PATH}/usr/include
          
          # 配置元数据
          cat > ${APPIMAGE_DST_PATH}/EasyKiConverter.desktop <<EOF
          [Desktop Entry]
          Type=Application
          Name=EasyKiConverter
          Comment=Convert LCSC and EasyEDA components to KiCad libraries
          Exec=EasyKiConverter
          Icon=app_icon
          Categories=Development;Electronics;
          Terminal=false
          EOF
          cp resources/icons/app_icon.png ${APPIMAGE_DST_PATH}/app_icon.png

          # 关键步骤：运行 linuxdeploy 填充依赖库 (Qt libs 等) 到 AppDir
          # 注意：这里不生成 AppImage 文件，只处理目录内容
          # --icon-file 参数必须指向 AppDir 中的图标文件，而不是源路径
          linuxdeploy --appdir ${APPIMAGE_DST_PATH} --plugin qt \
            --executable ${APPIMAGE_DST_PATH}/usr/bin/EasyKiConverter \
            --desktop-file ${APPIMAGE_DST_PATH}/EasyKiConverter.desktop \
            --icon-file ${APPIMAGE_DST_PATH}/app_icon.png

      - name: Upload AppDir Artifact
        uses: actions/upload-artifact@v4
        with:
          name: built-appdir
          path: ${{ github.workspace }}/${{ env.PRODUCT }}.AppDir
          retention-days: 1

  # ===========================================================================
  # 阶段 2: 独立打包任务 (Package Anywhere)
  # 并行执行，互不干扰
  # ===========================================================================

  pack-appimage:
    name: 'Package: AppImage'
    needs: build-core
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4 # 需要 checkout 以便 linuxdeploy 某些插件工作正常
      - uses: ./.github/actions/get-version
        id: version
      
      - name: Download AppDir
        uses: actions/download-artifact@v4
        with:
          name: built-appdir
          path: ${{ env.PRODUCT }}.AppDir

      - name: Debug - List AppDir
        run: ls -R ${{ env.PRODUCT }}.AppDir

      - name: Generate AppImage
        run: |
          # 重新运行 linuxdeploy 以生成 AppImage
          # 必须再次指定 executable 和 desktop-file 否则 AppRun 可能不会正确链接
          linuxdeploy --appdir ${{ env.PRODUCT }}.AppDir --plugin qt \
            --executable ${{ env.PRODUCT }}.AppDir/usr/bin/EasyKiConverter \
            --desktop-file ${{ env.PRODUCT }}.AppDir/EasyKiConverter.desktop \
            --output appimage
          
          # 重命名
          mv EasyKiConverter-*.AppImage \
             ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}.x86_64.AppImage
          
          # Checksum
          sha256sum *.AppImage | tee ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}.x86_64.AppImage.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg-appimage
          path: |
            *.AppImage
            *.sha256sum

  pack-deb:
    name: 'Package: DEB (Debian/Ubuntu)'
    needs: build-core
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/get-version
        id: version

      - name: Download AppDir
        uses: actions/download-artifact@v4
        with:
          name: built-appdir
          path: .

      - name: Debug - List AppDir
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Checking for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            echo "Found AppDir directory"
            ls -R ${{ env.PRODUCT }}.AppDir | head -50
          else
            echo "AppDir directory not found, checking for nested directories..."
            find . -maxdepth 2 -type d -name "AppDir" -o -name "usr" 2>/dev/null || true
          fi

      - name: Generate DEB
        run: |
          export VERSION="${{ steps.version.outputs.VERSION}}"
          
          # 自动检测 AppDir 位置
          echo "=== Searching for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/${{ env.PRODUCT }}.AppDir"
            echo "Found AppDir at: $APP_DIR"
          elif [ -d "AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/AppDir"
            echo "Found AppDir at: $APP_DIR"
          else
            # 检查当前目录是否包含 AppDir 的特征文件（usr/bin/EasyKiConverter）
            if [ -f "usr/bin/EasyKiConverter" ] && [ -f "AppRun" ]; then
              # nfpm 不支持使用根目录，需要创建一个子目录
              echo "Found AppDir structure in current directory, creating subdirectory for nfpm"
              mkdir -p AppDir_temp
              mv usr lib AppRun *.desktop app_icon.png AppDir_temp/ 2>/dev/null || true
              export APP_DIR="${GITHUB_WORKSPACE}/AppDir_temp"
              echo "Using AppDir at: $APP_DIR"
            else
              # 查找包含 usr/bin 的子目录
              FOUND_DIR=$(find . -maxdepth 2 -type d -name "usr" -not -path '.' -exec dirname {} \; 2>/dev/null | head -1)
              if [ -n "$FOUND_DIR" ] && [ "$FOUND_DIR" != "." ]; then
                export APP_DIR="${GITHUB_WORKSPACE}/${FOUND_DIR}"
                echo "Found AppDir-like structure at: $APP_DIR"
              else
                echo "ERROR: Could not find AppDir!"
                echo "Available directories:"
                find . -maxdepth 2 -type d
                exit 1
              fi
            fi
          fi
          
          echo "=== APP_DIR = $APP_DIR ==="
          echo "=== Verifying APP_DIR ==="
          ls -la "$APP_DIR" | head -20
          
          # 准备脚本
          mkdir -p scripts
          echo -e "#!/bin/sh\nif which update-desktop-database >/dev/null 2>&1; then update-desktop-database -q; fi" > scripts/postinstall.sh
          chmod +x scripts/*.sh

          # 打包（直接使用 APP_DIR 的绝对值，不依赖环境变量替换）
          nfpm pkg --packager deb --target . --config nfpm.yaml --env "APP_DIR=$APP_DIR"

          # 重命名
          find . -name "*.deb" -exec mv {} ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_amd64.deb \;
          
          # Checksum
          sha256sum *.deb | tee ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_amd64.deb.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg-deb
          path: |
            *.deb
            *.sha256sum

  pack-rpm:
    name: 'Package: RPM (RedHat/Fedora)'
    needs: build-core
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/get-version
        id: version

      - name: Download AppDir
        uses: actions/download-artifact@v4
        with:
          name: built-appdir
          path: .

      - name: Debug - List AppDir
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Checking for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            echo "Found AppDir directory"
            ls -R ${{ env.PRODUCT }}.AppDir | head -50
          else
            echo "AppDir directory not found, checking for nested directories..."
            find . -maxdepth 2 -type d -name "AppDir" -o -name "usr" 2>/dev/null || true
          fi

      - name: Generate RPM
        run: |
          export VERSION="${{ steps.version.outputs.VERSION}}"
          
          # 自动检测 AppDir 位置
          echo "=== Searching for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/${{ env.PRODUCT }}.AppDir"
            echo "Found AppDir at: $APP_DIR"
          elif [ -d "AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/AppDir"
            echo "Found AppDir at: $APP_DIR"
          else
            # 检查当前目录是否包含 AppDir 的特征文件（usr/bin/EasyKiConverter）
            if [ -f "usr/bin/EasyKiConverter" ] && [ -f "AppRun" ]; then
              # nfpm 不支持使用根目录，需要创建一个子目录
              echo "Found AppDir structure in current directory, creating subdirectory for nfpm"
              mkdir -p AppDir_temp
              mv usr lib AppRun *.desktop app_icon.png AppDir_temp/ 2>/dev/null || true
              export APP_DIR="${GITHUB_WORKSPACE}/AppDir_temp"
              echo "Using AppDir at: $APP_DIR"
            else
              # 查找包含 usr/bin 的子目录
              FOUND_DIR=$(find . -maxdepth 2 -type d -name "usr" -not -path '.' -exec dirname {} \; 2>/dev/null | head -1)
              if [ -n "$FOUND_DIR" ] && [ "$FOUND_DIR" != "." ]; then
                export APP_DIR="${GITHUB_WORKSPACE}/${FOUND_DIR}"
                echo "Found AppDir-like structure at: $APP_DIR"
              else
                echo "ERROR: Could not find AppDir!"
                echo "Available directories:"
                find . -maxdepth 2 -type d
                exit 1
              fi
            fi
          fi
          
          echo "=== APP_DIR = $APP_DIR ==="
          echo "=== Verifying APP_DIR ==="
          ls -la "$APP_DIR" | head -20
          
          mkdir -p scripts && echo "#!/bin/sh" > scripts/postinstall.sh && chmod +x scripts/*.sh

          nfpm pkg --packager rpm --target . --config nfpm.yaml --env "APP_DIR=$APP_DIR"

          find . -name "*.rpm" -exec mv {} ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_x86_64.rpm \;
          sha256sum *.rpm | tee ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_x86_64.rpm.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg-rpm
          path: |
            *.rpm
            *.sha256sum

  pack-arch:
    name: 'Package: Arch Linux'
    needs: build-core
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/tangsangsimida/easykiconverter/build-env:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/get-version
        id: version

      - name: Download AppDir
        uses: actions/download-artifact@v4
        with:
          name: built-appdir
          path: .

      - name: Debug - List AppDir
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Checking for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            echo "Found AppDir directory"
            ls -R ${{ env.PRODUCT }}.AppDir | head -50
          else
            echo "AppDir directory not found, checking for nested directories..."
            find . -maxdepth 2 -type d -name "AppDir" -o -name "usr" 2>/dev/null || true
          fi

      - name: Generate Arch Package
        run: |
          export VERSION="${{ steps.version.outputs.VERSION}}"
          
          # 自动检测 AppDir 位置
          echo "=== Searching for AppDir ==="
          if [ -d "${{ env.PRODUCT }}.AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/${{ env.PRODUCT }}.AppDir"
            echo "Found AppDir at: $APP_DIR"
          elif [ -d "AppDir" ]; then
            export APP_DIR="${GITHUB_WORKSPACE}/AppDir"
            echo "Found AppDir at: $APP_DIR"
          else
            # 检查当前目录是否包含 AppDir 的特征文件（usr/bin/EasyKiConverter）
            if [ -f "usr/bin/EasyKiConverter" ] && [ -f "AppRun" ]; then
              # nfpm 不支持使用根目录，需要创建一个子目录
              echo "Found AppDir structure in current directory, creating subdirectory for nfpm"
              mkdir -p AppDir_temp
              mv usr lib AppRun *.desktop app_icon.png AppDir_temp/ 2>/dev/null || true
              export APP_DIR="${GITHUB_WORKSPACE}/AppDir_temp"
              echo "Using AppDir at: $APP_DIR"
            else
              # 查找包含 usr/bin 的子目录
              FOUND_DIR=$(find . -maxdepth 2 -type d -name "usr" -not -path '.' -exec dirname {} \; 2>/dev/null | head -1)
              if [ -n "$FOUND_DIR" ] && [ "$FOUND_DIR" != "." ]; then
                export APP_DIR="${GITHUB_WORKSPACE}/${FOUND_DIR}"
                echo "Found AppDir-like structure at: $APP_DIR"
              else
                echo "ERROR: Could not find AppDir!"
                echo "Available directories:"
                find . -maxdepth 2 -type d
                exit 1
              fi
            fi
          fi
          
          echo "=== APP_DIR = $APP_DIR ==="
          echo "=== Verifying APP_DIR ==="
          ls -la "$APP_DIR" | head -20
          
          mkdir -p scripts && echo "#!/bin/sh" > scripts/postinstall.sh && chmod +x scripts/*.sh

          nfpm pkg --packager archlinux --target . --config nfpm.yaml --env "APP_DIR=$APP_DIR"

          find . -name "*.pkg.tar.zst" -exec mv {} ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_x86_64.pkg.tar.zst \;
          sha256sum *.pkg.tar.zst | tee ${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_x86_64.pkg.tar.zst.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg-arch
          path: |
            *.pkg.tar.zst
            *.sha256sum

  # ===========================================================================
  # 阶段 3: 独立构建系统任务 (Flatpak & Snap)
  # 它们有自己的构建流程，无法复用 build-core 的 AppDir
  # ===========================================================================

  pack-flatpak:
    name: 'Package: Flatpak'
    runs-on: ubuntu-latest
    container:
      image: bilelmoussaoui/flatpak-github-actions:kde-6.6
      options: --privileged
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: ./.github/actions/get-version
        id: version
      - run: git config --global --add safe.directory $GITHUB_WORKSPACE

      - name: Prepare Flatpak Source
        run: |
          # 将源代码复制到 flatpak 目录中，以便 flatpak-builder 能找到
          # 使用 cp 命令代替 rsync（容器中可能没有 rsync）
          mkdir -p flatpak
          
          # 复制所有文件和目录（排除不需要的）
          for item in *; do
            case "$item" in
              .git|build|temp_project|test_date|demo|.github|snap|flatpak|nfpm.yaml|mkdocs.yml|AGENTS.md|GEMINI.md|*.md)
                # 跳过这些文件/目录
                ;;
              *)
                # 复制其他文件/目录
                cp -r "$item" flatpak/
                ;;
            esac
          done
          
          # 复制隐藏文件（如 .clang-format, .gitignore）
          for hidden in .clang-format .gitignore; do
            if [ -f "$hidden" ]; then
              cp "$hidden" flatpak/
            fi
          done

      - name: Build Flatpak
        uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        with:
          bundle: EasyKiConverter.flatpak
          manifest-path: flatpak/com.tangsangsimida.EasyKiConverter.yml
          cache-key: flatpak-builder-${{ github.sha }}

      - name: Rename & Checksum
        run: |
          FILENAME=${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}.flatpak
          mv EasyKiConverter.flatpak $FILENAME
          sha256sum $FILENAME | tee $FILENAME.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg-flatpak
          path: |
            *.flatpak
            *.sha256sum

  pack-snap:
    name: 'Package: Snap'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: ./.github/actions/get-version
        id: version
      
      - name: Prepare Snap Source
        run: |
          # 将源代码复制到 snap 目录中，以便 snapcraft 能找到 CMakeLists.txt
          # 使用 cp 命令代替 rsync
          mkdir -p snap
          
          # 复制所有文件和目录（排除不需要的）
          for item in *; do
            case "$item" in
              .git|build|temp_project|test_date|demo|.github|flatpak|snap|nfpm.yaml|mkdocs.yml|AGENTS.md|GEMINI.md|*.md)
                # 跳过这些文件/目录
                ;;
              *)
                # 复制其他文件/目录
                cp -r "$item" snap/
                ;;
            esac
          done
          
          # 复制隐藏文件（如 .clang-format, .gitignore）
          for hidden in .clang-format .gitignore; do
            if [ -f "$hidden" ]; then
              cp "$hidden" snap/
            fi
          done
      
      - name: Build Snap
        uses: snapcore/action-build@v1
        id: snapbuild
        with:
          path: snap

      - name: Rename & Checksum
        run: |
          FILENAME=${{ env.PRODUCT }}-${{ steps.version.outputs.VERSION }}-g${{ steps.version.outputs.GIT_HASH }}_amd64.snap
          find . -name "*.snap" -exec mv {} $FILENAME \;
          sha256sum $FILENAME | tee $FILENAME.sha256sum

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg-snap
          path: |
            *.snap
            *.sha256sum

  # ===========================================================================
  # 阶段 4: 发布
  # 汇总所有工件并发布
  # ===========================================================================
  release:
    name: 'Publish Release'
    if: startsWith(github.ref, 'refs/tags/')
    needs: [pack-appimage, pack-deb, pack-rpm, pack-arch, pack-flatpak, pack-snap]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: pkg-*
          merge-multiple: true
          path: release_assets

      - name: Upload Release Asset
        uses: softprops/action-gh-release@v2
        with:
          files: release_assets/*
          generate_release_notes: true
          draft: true
          prerelease: false
          fail_on_unmatched_files: false
